<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="Stylesheet" type="text/css" href="../style.css">
<title>数组和指针</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>

<h1 id="toc_1"> 数组</h1>
<p>
数组的长度是固定的!
定义方法:
</p>
<blockquote>
int a[] = {1,2,3};//显示初始化时,可以省略维数(编译器确定数组长度) 
int a[4] = {1,2}; //只初始化a[0],a[1]. a[2],a[3]不会初始化(函数体内)或者初始化为0(函数体外)
如果是类类型,自动调用默认构造函数初始化
</blockquote>
<p>
存放a[5]的地址和a[4]的地址是连续的,不管a[5]的位置上存放的是什么,都以int的形式的读出.
访问:
</p>
<blockquote>
a[0] 等同 *(a)
a[1] 等同 *(a+1)
</blockquote>

<h1 id="toc_2"> 字符数组,有点特殊</h1>
<h2 id="toc_2.1"> 1</h2>
<p>
字符数组还可以用字符串字面值初始化,即:
</p>
<blockquote>
char a1[] = "C++";
</blockquote>
<p>
这个数组的维数是4而不是3,因为自动在结尾添加'\0'(null)
</p>
<h2 id="toc_2.2"> 2</h2>
<p>
还可以这样表示:(C风格字符串)
</p>
<blockquote>
char *a2 = "C++";
</blockquote>
<h2 id="toc_2.3"> 3</h2>
<p>
a1和a2的类型是一样的.
</p>

<p>
a1代表即代表第一个元素的指针,也表示字符串对象.而数组的类型是其他(如int a[]),a代表第一个元素的指针.
</p>

<p>
但是于此同时,字符串可以同其他数组一样通过指针遍历元素.
</p>
<pre>
    char *a="abc";
    int *b={1,2,3};
    for(int i=0;i&lt;3;i++)
    {
        cout&lt;&lt;*(a+i)&lt;&lt;endl;//依次输出a,b,c
        cout&lt;&lt;*(b+i)&lt;&lt;endl;//依次输出1,2,3
        cout&lt;&lt;&amp;*(a+i)&lt;&lt;endl;//依次输出元素地址
        cout&lt;&lt;&amp;*(b+i)&lt;&lt;endl;//输出从该地址开始的字符串abc,bc,c
    }
</pre>

<p>
可以作出这样的判断:a是指针,
</p>
<h1 id="toc_3"> 一个区别</h1>
<pre>
    string s = "abc";
    string *sp = &amp;s; //把string对象s的地址附给sp
    cout&lt;&lt;*sp&lt;&lt;endl; //得到"abc"
    *sp = "A new word";//把sp指向的内容用字符串字面值替代
    cout&lt;&lt;*sp&lt;&lt;endl; //得到"A new word"
</pre>
<h1 id="toc_4"> 不要忘记字符串结束符null</h1>
<p>
标准库函数(#include&lt;cstring&gt;)是string.h头文件的c++版本
</p>
<blockquote>
char a[]={'c','+','+'};
cout&lt;&lt;strlen(a)&lt;&lt;endl;//disaster:a is not null-terminated
标准库函数总是假定其参数字符串以null结尾 
</blockquote>

<h1 id="toc_5"> 新旧代码的兼容</h1>
<p>
C风格字符串与字符串字面值有相同的数据结构,而且都以null结束,因此可以互相代替.
</p>
<blockquote>
const char *a="abc";
string b(a);
</blockquote>

</body>
</html>
