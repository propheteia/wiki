<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <meta charset="utf-8"/>
    <meta name="description" content="">
    <meta name="author" content="">
    <meta property="wb:webmaster" content="3caf5a5b94e6991e" />
    
    <link rel="shortcut icon" href="../template/coolblue/images/chine.ico"/>
    
    <title> distutils 模块  | winoi</title>
    
    <link type="text/css" rel="stylesheet" href="../template/coolblue/css/bootstrap.min.css"><link>
    <link rel="stylesheet" type="text/css" media="screen" href="../template/coolblue/css/coolblue.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="../template/coolblue/css/chine.css" />
    
    <script src="../template/coolblue/js/jquery-1.7.2.min.js"></script>
    <script src="../template/coolblue/js/scrollToTop.js"></script>
    <script src="../template/coolblue/js/inputFocusOrBlur.js"></script>
    <script src="../template/coolblue/js/jquery.form.js"></script> 
    <script src="../template/coolblue/js/bootstrap-transition.js"></script> 
    <script src="../template/coolblue/js/bootstrap-tooltip.js"></script>
    <script src="../template/coolblue/js/bootstrap-modal.js"></script> 
    <script src="../template/coolblue/js/subscribe.js"></script> 
    
    <!--[if lt IE 9]>
        <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    
    
</head>
<body id="top">
    
    <!--header -->
<div id="header-wrap"><header>
    <hgroup>
        <h1>distutils 模块 </h1>
    </hgroup>

    <nav>
        <ul>
            <li><a href="http://www.winoi.com">首页</a><span></span></li>
            <li id="current"><a href="../index.html">笔记目录</a><span></span></li>
            <li><a href="../about.html">关于</a><li>
        </ul>
    </nav>

<!--/header-->
</header></div>

    
    <!-- content-wrap -->
    <div id="content-wrap">
        <!-- content -->
        <div id="content" class="clearfix">
    &nbsp;
           
<h1 id="toc_1"> 包和模块的文件模型</h1>
<p>
如果你发现自己正在用 Python 编写一个大型的子系统 (或者，很有可能，当你意识到你的小型子系统已经成长为一个大型子系统时)，你应该花费些时间设计一个好的包架构。它是 Python 所擅长的事情之一，所以应该好好利用它。 
</p>

<pre>
    包和模块模型:
    exercise
        |--__init__.py
        |
        |--module_a.py
        |        |-- class football
        |        |-- class TTException
        |
        |--module_b.py
                 |-- function go_for_basketball
    如果__init__.py必须有,这样才能导入以下两个模块 
        import exercise.module_a.football

    如果要通过包直接找到某个类或者函数,则可以通过在__init__.py中import该类或函数
    此时在__init__.py中添加    
        from module_a import football
    那么在调用football方法时,可以这样
        from exercise import football
</pre>

<h2 id="toc_1.1"> setup.py</h2>
<pre>
from distutils.core import setup
setup(
    name="exercise",
    license="RA",
    version="0.1.1",
    description="Automation Test module for python",
    author="Wenbin Wang",
    author_email="wenbin.rc@gmail.com",
    packages=["exercise"],      -- 需要安装的文件夹(包)
    long_description="""AutoTest is a test platphome for RA,PowerMonitor development te\
                        team.""",
    )
运行结果在site-package下面产生包(exercise),
和一个名为"exercise-0.1.1-py2.7.egg-info"的文件
内容如下:
    Metadata-Version: 1.0
    Name: exercise
    Version: 0.1.1
    Summary: Automation Test module for python
    Home-page: UNKNOWN
    Author: Wenbin Wang
    Author-email: wenbin.rc@gmail.com
    License: RA
    Description: AutoTest is a test platphome for RA,PowerMonitor development team
    Platform: UNKNOWN
</pre>

<h1 id="toc_2"> python寻找模块的顺序</h1>
<pre>
1. 首先判断这个module是不是built-in即内建模块，
　 如果是则引入内建模块，如果不是则在一个称为sys.path的list中寻找

2. sys.path在python脚本执行时动态生成，包括以下3个部分：
　　a.脚本执行的位置，即当前路径
　　b.环境变量中的PYTHONPATH, 即.bash_profile
　　c.安装python时的依赖位置(通常是"../python2.7/site-packages")

执行python setup.py install 实际上做了两件事:
1. 将包(模块)添加到python系统路径下(site-packages)
2. 生成egg-info的文件,包含包的信息
</pre>

<h1 id="toc_3"> 上传包,pip安装</h1>
<ul>
<li>
<a href="http://www.ibm.com/developerworks/opensource/library/os-pythonpackaging/index.html">http://www.ibm.com/developerworks/opensource/library/os-pythonpackaging/index.html</a> ,

<li>
<a href="http://docs.python.org/2/distutils/packageindex.html#package-index">http://docs.python.org/2/distutils/packageindex.html#package-index</a>

<li>
<a href="https://pypi.python.org/pypi/mypypi">https://pypi.python.org/pypi/mypypi</a>

</ul>

<h1 id="toc_4"> 特殊的_<em>init</em>_.py</h1>
<pre>
run.py
|--app
    |--__init__.py
    |--views.py
</pre>

<p>
_<em>init</em>_.py
</p>
<pre>
app=Flask(__name__)
</pre>

<p>
views.py
</p>
<pre>
from app import app
</pre>

<p>
run.py
</p>
<pre>
    from app import app
    from app.views import *
</pre>

<p>
这样是可行的,但是views.py在模块内不能被引用,只有对其作为包的一部分引用
</p>

<p>
若想让其在包内可以被作为模块引用,可以这样改:
</p>

<p>
views.py
</p>
<pre>
from __init__ import app
</pre>

<p>
但是这样改在运行run的时候出现问题了,原因在于:
</p>
<pre>
    通过比较app.__setattri__发现
    run中的app和views中的app指向不同的地址,所以出现无法定向的错误
    run中引用的是一个包中的某个对象,而views引用的是模块中的对象
</pre>

<p>
从python2.7用户手册中了解到,可以这样
views.py
</p>
<pre>
from . import app
</pre>
<p>
当然也表示从包中引用
</p>

<p>
但如果_<em>init</em>_.py改为别的名称(比如test),则没有问题.
run.py
</p>
<pre>
    from app.test import app
    from app.views import *
</pre>
<p>
他们都是从模块中导入的app
</p>

<p>
这里可见_<em>init</em>_.py不易被察觉的特殊性
</p>
 
        <div>
   <div>

<!-- footer -->
<footer>
    <p class="footer-left">
        &copy; 2013 Copyright Info &nbsp; &nbsp; &nbsp;
         powered by <a href="http://www.vim.org/scripts/script.php?script_id=2226", target="_blank">vimwiki</a>
    </p>

    <p class="footer-right">
        <a href="../index.html">Home</a> |
        <a href="#top" class="back-to-top">Back to Top</a>
    </p>
<!-- /footer -->
</footer>

</body>
