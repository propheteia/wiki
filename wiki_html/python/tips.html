<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <meta charset="utf-8"/>
    <meta name="description" content="">
    <meta name="author" content="">
    <meta property="wb:webmaster" content="3caf5a5b94e6991e" />
    
    <link rel="shortcut icon" href="../template/coolblue/images/chine.ico"/>
    
    <title> Python | winoi</title>
    
    <link type="text/css" rel="stylesheet" href="../template/coolblue/css/bootstrap.min.css"><link>
    <link rel="stylesheet" type="text/css" media="screen" href="../template/coolblue/css/coolblue.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="../template/coolblue/css/chine.css" />
    
    <script src="../template/coolblue/js/jquery-1.7.2.min.js"></script>
    <script src="../template/coolblue/js/scrollToTop.js"></script>
    <script src="../template/coolblue/js/inputFocusOrBlur.js"></script>
    <script src="../template/coolblue/js/jquery.form.js"></script> 
    <script src="../template/coolblue/js/bootstrap-transition.js"></script> 
    <script src="../template/coolblue/js/bootstrap-tooltip.js"></script>
    <script src="../template/coolblue/js/bootstrap-modal.js"></script> 
    <script src="../template/coolblue/js/subscribe.js"></script> 
    
    <!--[if lt IE 9]>
        <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    
    
</head>
<body id="top">
    
    <!--header -->
<div id="header-wrap"><header>
    <hgroup>
        <h1>Python</h1>
    </hgroup>

    <nav>
        <ul>
            <li><a href="http://www.winoi.com">首页</a><span></span></li>
            <li id="current"><a href="../index.html">笔记目录</a><span></span></li>
            <li><a href="../about.html">关于</a><li>
        </ul>
    </nav>

<!--/header-->
</header></div>

    
    <!-- content-wrap -->
    <div id="content-wrap">
        <!-- content -->
        <div id="content" class="clearfix">
    &nbsp;
           
<div class="toc">
<ul>
<li><a href="#toc_1">with:</a>
<li><a href="#toc_2">当模块与其包含的包重名</a>
<li><a href="#toc_3">hasattr()和 getattr()</a>
<li><a href="#toc_4">函式编程</a>
<ul>
<li><a href="#toc_4.1">map</a>
</ul>
<li><a href="#toc_5">filter</a>
<li><a href="#toc_6">reduce</a>
<li><a href="#toc_7">xlrd</a>
<li><a href="#toc_8">*args **kwargs</a>
<li><a href="#toc_9">函数式编程</a>
<li><a href="#toc_10">yield</a>
<li><a href="#toc_11">tuple有什么好处?</a>
<li><a href="#toc_12">wtform的一个getattr</a>
</ul>
</div>
<h1 id="toc_1">with:</h1>
<pre class="brush:python">
import sys
class test:
    def __enter__(self):
           print "enter"
           return 1
    def __exit__(self,*args):
           print "exit"
           return True
with test() as t:
    print "t is %s, yes, it is "%t #.format(t)
print "end"
</pre>
<p>
运行结果:
</p>
<blockquote>
enter
t is 1, yes, it is 
exit
end
</blockquote>
<h1 id="toc_2">当模块与其包含的包重名</h1>
<p>
创建文件：
</p>
<blockquote>
vim logging.py
</blockquote>
<p>
编辑脚本：
</p>
<pre class="brush:python">
    import logging
    logging.warning("watch out!")
    logging.info("I told you so")
</pre>
<p>
运行错误:
</p>
<pre>
    Traceback (most recent call last):
  File "logging.py", line 1, in &lt;module&gt;
    import logging
  File "/home/wenbin/test-dir/logging.py", line 2, in &lt;module&gt;
    logging.warning("watch out!")
AttributeError: 'module' object has no attribute 'warning'
</pre>
<p>
错误信息中看出，import搜索的路径当前文件夹处于优先位置。因此
新建的文件名要避免"普通“
</p>

<h1 id="toc_3">hasattr()和 getattr()</h1>
<p>
hasattr()和 getattr()分别判断对象是否有某个属性及获得某个属性值。
In [35]: hasattr(a, 'split')
Out[35]: True
In [36]: getattr(a, 'split')
Out[36]: &lt;built-in method split of str object at 0x831abe0&gt;
</p>

<h1 id="toc_4">函式编程</h1>
<p>
在函式编程中,最著名的特色就是高序(High Order)。简单地说,就是定制一个算法,按规则来指定容器中的每一个元素。最常用的 High Order 为:
</p>
<ul>
<li>
映射,也就是将算法施于每个元素,将返回值合并为一个新的容器。

<li>
过滤,将算法施于每个元素,将返回值为真的元素合并为一个新的容器。

<li>
合并,将算法(可能携带一个初值)依次施于每个元素,将返回值作为下一步计算

<li>
的参数之一,与下一个元素再计算,直至最终获得一个总的结果。

</ul>
<h2 id="toc_4.1">map</h2>
<pre def foo(x):>

        return x*x

 print map(foo, range(10))
</pre>
<p>
map 允许接收三个或三个以上的参数
</p>

<p>
用途:函数要执行多次,且参数有一定的规律
</p>
<h1 id="toc_5">filter</h1>
<p>
用途:对结果过滤
</p>
<h1 id="toc_6">reduce</h1>
<p>
用途:方便地实现了计算结果的重用,节省了大量的 CPU 周期。在实际应用中,reduce 可以用来实现统计计算或时序依赖的遍历行为。
</p>

<h1 id="toc_7">xlrd</h1>
<p>
Open the workbook
</p>
<pre class="brush:python">
import xlrd
wb = xlrd.open_workbook('myworkbook.xls')
Check the sheet names
wb.sheet_names()
Get the first sheet either by index or by name
sh = wb.sheet_by_index(0)
sh = wb.sheet_by_name(u'Sheet1')
</pre>
<p>
Iterate through rows, returning each as a list that you can index:
</p>
<pre class="brush:python">
for rownum in range(sh.nrows):
    print sh.row_values(rownum)
</pre>
<p>
If you just want the first column:
</p>
<pre class="brush:python">
first_column = sh.col_values(0)
</pre>
<p>
Index individual cells:
</p>
<pre class="brush:python">
cell_A1 = sh.cell(0,0).value
cell_C4 = sh.cell(rowx=3,colx=2).value
</pre>
<p>
附文：python 解析xml
~                    
</p>
<h1 id="toc_8">*args **kwargs</h1>
<p>
*args表示任何多个无名参数，它是一个tuple； **kwargs表示关键字参数，它是一个dict。并且同时使用<strong>args和</strong>*kwargs时，必须<strong>args参数列要在</strong>*kwargs前.
</p>
<pre>
def foo(*args, **kwargs):
    print 'args = ', args
    print 'kwargs = ', kwargs
    print '---------------------------------------'

if __name__ == '__main__':
    foo(1,2,3,4)
    foo(a=1,b=2,c=3)
    foo(1,2,3,4, a=1,b=2,c=3)
    foo('a', 1, None, a=1, b='2', c=3)
</pre>
<p>
看到xlrd模块的安装包是这样得到安装信息的dict的
</p>
<pre>
def mkargs(**kwargs):    
    return kwargs

args = mkargs(
    name = 'xlrd',
    version = __VERSION__,    
    author = 'John Machin',   
    author_email = 'sjmachin@lexicon.net', 
    url = the_url,       
    packages = ['xlrd'], 
    scripts = [
        'scripts/runxlrd.py',     
        ],
    description = 'Library for developers to extract data from Microsoft Excel (tm) spreadsheet files',
    long_description = \
        "Extract data from Excel spreadsheets (XLS only, versions 2.0 to 2003) on any platform. " \
        "Pure Python (2.6 to 2.7). Strong support for Excel dates. Unicode-aware.",
    platforms = ["Any platform -- don't need Windows"],
    license = 'BSD',
    keywords = ['xls', 'excel', 'spreadsheet', 'workbook'],
    )

args23 = mkargs(
    download_url = the_url,   
    classifiers = [
        'Development Status :: 5 - Production/Stable',
        'Intended Audience :: Developers',
        'License :: OSI Approved :: BSD License',
        'Programming Language :: Python',
        'Operating System :: OS Independent',
        'Topic :: Database',      
        'Topic :: Office/Business',
        'Topic :: Software Development :: Libraries :: Python Modules',
        ],           
    )                

args.update(args23)

这里,update将dict args23合并到args
</pre>
<p>
这样返回的就是个dict
</p>
<h1 id="toc_9">函数式编程</h1>
<pre>
    def good():
        t=good.t
        print type(t)
    
    good.t=0 #在函数外将函数内的变量赋值
    if __name__=="__main__":
        good()
</pre>
<h1 id="toc_10">yield</h1>
<p>
带有 yield 的函数在 Python 中被称之为 generator（生成器）
版本一:
</p>
<pre>
                
 def fab(max): 
    n, a, b = 0, 0, 1 
    L = [] 
    while n &lt; max: 
        L.append(b) 
        a, b = b, a + b 
        n = n + 1 
    return L 
</pre>
<p>
版本二:
</p>
<pre>
 class Fab(object): 

    def __init__(self, max): 
        self.max = max 
        self.n, self.a, self.b = 0, 0, 1 

    def __iter__(self): 
        return self 

    def next(self): 
        if self.n &lt; self.max: 
            r = self.b 
            self.a, self.b = self.b, self.a + self.b 
            self.n = self.n + 1 
            return r 
        raise StopIteration() 
</pre>
<p>
yield版本三:
</p>
<pre>
 def fab(max): 
    n, a, b = 0, 0, 1 
    while n &lt; max: 
        yield b 
        #print b 
        a, b = b, a + b 
        n = n + 1 

 for i in fab(5):
    print i
</pre>

<p>
简单地讲，yield 的作用就是把一个函数变成一个 generator，带有 yield 的函数不再是一个普通函数，Python 解释器会将其视为一个 generator，调用 fab(5) 不会执行 fab 函数，而是返回一个 iterable 对象！在 for 循环执行时，每次循环都会执行 fab 函数内部的代码，执行到 yield b 时，fab 函数就返回一个迭代值，下次迭代时，代码从 yield b 的下一条语句继续执行，而函数的本地变量看起来和上次中断执行前是完全一样的，于是函数继续执行，直到再次遇到 yield。
</p>

<p>
我的理解,以上三个版本的本质区别在于,第一个版本按照某种方式产生数据,并将其存放(在List),需要时直接从list中调用.而版本三只在需要时以某种方式产生数据,因此不需要空间来存放.
转:<a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/">developerworks</a>
</p>

<h1 id="toc_11">tuple有什么好处?</h1>
<blockquote>
Tuple 比 list 操作速度快。如果您定义了一个值的常量集，并且唯一要用它做的是不断地遍历它，请使用 tuple 代替 list。
</blockquote>
<blockquote>
如果对不需要修改的数据进行 “写保护”，可以使代码更安全。使用 tuple 而不是 list 如同拥有一个隐含的 assert 语句，说明这一数据是常量。如果必须要改变这些值，则需要执行 tuple 到 list 的转换 (需要使用一个特殊的函数)。
</blockquote>
<blockquote>
还记得我说过 dictionary keys 可以是字符串，整数和 “其它几种类型”吗？Tuples 就是这些类型之一。Tuples 可以在 dictionary 中被用做 key，但是 list 不行。实际上，事情要比这更复杂。Dictionary key 必须是不可变的。Tuple 本身是不可改变的，但是如果您有一个 list 的 tuple，那就认为是可变的了，用做 dictionary key 就是不安全的。只有字符串、整数或其它对 dictionary 安全的 tuple 才可以用作 dictionary key。
</blockquote>
<blockquote>
Tuples 可以用在字符串格式化中.
</blockquote>
<blockquote>
tuple和list可以相互转换. a=[]  b=tuple(a) type(b) --&gt; tuple
</blockquote>


<h1 id="toc_12">wtform的一个getattr</h1>
<pre>
def validate(self):                                                        
    """                                                                    
    Validates the form by calling `validate` on each field, passing any    
    extra `Form.validate_&lt;fieldname&gt;` validators to the field validator.   
    """                                                                    
    extra = {}                                                             
    for name in self._fields:                                              
        inline = getattr(self.__class__, 'validate_%s' % name, None)       
        if inline is not None:                                                                                                                 
            extra[name] = [inline]                                         
                                                                           
    return super(Form, self).validate(extra)    
</pre>
 
        <div>
   <div>

<!-- footer -->
<footer>
    <p class="footer-left">
        &copy; 2013 Copyright Info &nbsp; &nbsp; &nbsp;
         powered by <a href="http://www.vim.org/scripts/script.php?script_id=2226", target="_blank">vimwiki</a>
    </p>

    <p class="footer-right">
        <a href="../index.html">Home</a> |
        <a href="#top" class="back-to-top">Back to Top</a>
    </p>
<!-- /footer -->
</footer>

</body>
